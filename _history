{"entries":[{"timestamp":1745391880918,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":181,"length1":43,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":210,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"custom.ts","value":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=images\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}\n\n//namespace images {\n\n    /**\n     * Print centered text on the image\n     */\n    //% blockId=imagesprinttextcenter block=\"print $i center $text at y $y in color $color\"\n    //% i.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    //export function printCenter(i: Image, text: string, y: number, color: number) {\n        //i.printCenter(text, y, color)\n    //}\n//}"}]},{"timestamp":1745392480362,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"^$H1{V{B%i%h3;eZ9E?k\">picture</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":204,"length1":18,"diffs":[[1,"        \"custom.ts\"\n"]]},{"start1":231,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"removed","filename":"custom.ts","value":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=images\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}\n\n//namespace images {\n\n    /**\n     * Print centered text on the image\n     */\n    //% blockId=imagesprinttextcenter block=\"print $i center $text at y $y in color $color\"\n    //% i.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    //export function printCenter(i: Image, text: string, y: number, color: number) {\n        //i.printCenter(text, y, color)\n    //}\n//}"},{"type":"added","filename":"text.ts","value":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}"}]},{"timestamp":1745392759480,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"42\" y=\"46\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":204,"length1":38,"diffs":[[1,"        \"text.ts\"\n"]]},{"start1":229,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]},{"type":"added","filename":"menus.ts","value":"//% color=\nnamespace menus {\n\n}\n"}]},{"timestamp":1745393213483,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"//% color=\n"]]},{"start1":29,"length1":43,"diffs":[[1,""]]},{"start1":30,"length1":7,"diffs":[[1,"}\n"]]}]}]},{"timestamp":1745394282776,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":0,"length1":34,"diffs":[[1,"//% color=\"#ff0000\" icon=\"\\f00b\"\n"]]}]}]},{"timestamp":1745394731871,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":0,"length1":55,"diffs":[[1,"//% color=\"#ff0000\" icon=\"\\uf00b\"\n"]]},{"start1":52,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1745395296591,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":0,"length1":52,"diffs":[[1,"//% color=\"#FFAB19\" icon=\"\\uf00b\"\n//% group=\"Advanced\"\n"]]},{"start1":74,"length1":136,"diffs":[[1,""]]}]}]},{"timestamp":1745395767213,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":223,"length1":44,"diffs":[[1,"        \"menus.ts\"\n"]]}]},{"type":"edited","filename":"menus.ts","patch":[{"start1":0,"length1":50,"diffs":[[1,""]]},{"start1":52,"length1":348,"diffs":[[1,"namespace menus {\n"]]},{"start1":71,"length1":586,"diffs":[[1,"    /**\n     * Things a menu will need:\n     * Buttons\n     * Screens\n     * States\n     * Contextual actions\n     * Displays\n     */\n"]]},{"start1":206,"length1":340,"diffs":[[1,""]]},{"start1":207,"length1":375,"diffs":[[1,"    //% block\n    export function test() {\n\n"]]}]},{"type":"added","filename":"vectorMath.ts","value":"// Add your code here\n\nnamespace Math {\n    // Define a 2D vector structure\n    export type Vector2 = { x: number; y: number }\n\n    // Predefined directional vectors\n    export const Vector2 = {\n        up: { x: 0, y: -1 },\n        down: { x: 0, y: 1 },\n        left: { x: -1, y: 0 },\n        right: { x: 1, y: 0 },\n        zero: { x: 0, y: 0 },\n        one: { x: 1, y: 1 },\n\n        // Optional: utility functions\n        add: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x + b.x, y: a.y + b.y }),\n        sub: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x - b.x, y: a.y - b.y }),\n        scale: (v: Vector2, s: number): Vector2 => ({ x: v.x * s, y: v.y * s }),\n        dot: (a: Vector2, b: Vector2): number => a.x * b.x + a.y * b.y,\n        magnitude: (v: Vector2): number => Math.sqrt(v.x * v.x + v.y * v.y),\n        normalize: (v: Vector2): Vector2 => {\n            const mag = Vector2.magnitude(v)\n            return mag === 0 ? Vector2.zero : { x: v.x / mag, y: v.y / mag }\n        }\n    }\n}\n"}]},{"timestamp":1745642789741,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1609,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":243,"length1":72,"diffs":[[1,"        \"vectorMath.ts\"\n"]]}]},{"type":"edited","filename":"menus.ts","patch":[{"start1":0,"length1":48,"diffs":[[1,"// MenuUI.ts - Extension Helper for Menu Screens\n"]]},{"start1":102,"length1":78,"diffs":[[1,"namespace menuUI {\n    // Define the structure of a single button in the menuUI\n"]]},{"start1":216,"length1":81,"diffs":[[1,"        sprite: Sprite // The button's sprite (visual representation on screen)\n"]]},{"start1":344,"length1":246,"diffs":[[1,"        onSelect?: () => void \n        onHighlight?: () => void \n        onUnhighlight?: () => void\n"]]},{"start1":517,"length1":516,"diffs":[[1,"        buttons: MenuButton[] // List of buttons in the menu\n        selectedIndex: number // Track index of currently selected button\n        active: boolean // Track state of menu (visible on screen)\n        highlightSprite?: Sprite // Optional sprite that visually highlights the selected button\n        onLayoutUpdate?: (menu: Menu) => void // Optional callback to update the layout when the selection changes\n        usePositionNavigation?: boolean // Optional toggle for navigation based on button positions\n"]]},{"start1":1379,"length1":610,"diffs":[[1,""]]},{"start1":1423,"length1":4528,"diffs":[[1,"    export function addButton(menu: Menu, sprite: Sprite, onSelect?: ()=> void, onHighlight?: ()=> void, onUnhighlight?: ()=> void): MenuButton {\n        const btn: MenuButton = {\n            sprite: sprite, // Set the button's Sprite\n            onSelect: onSelect, // Set the onSelect callback if provided\n"]]},{"start1":1754,"length1":29,"diffs":[[1,""]]}]},{"type":"added","filename":"images.g.jres","value":"{\n    \"image1\": {\n        \"data\": \"hwQgABAAAAAAiIiIiIiIAICIiIiIiIgIiIiIiIiIiIiIiP+PiI+IiIiIj/iIj4iIiIiPiP+PiIiIiIiIiIiIiIiIj4iIiIiIiIiPiIiIiIiIiP///4+IiIiIj4iIiIiIiIiPiIiIiIiIiIiIiIiIiIiIiPj/j4iIiIj4j4+IiIiIiI+Ij4iIiIiI+I+PiIiIiIiI+P+PiIiIiIiIiIiIiIiI////j4iIiIiP+IiIiIiIiI/4j4iIiIiI+I/4j4iIiIiIiIiIiIiIiI+IiIiIiIiIj4iIiIiIiIj///+PiIiIiI+IiIiIiIiIj4iIiIiIiIiIiIiIiIiAiIiIiIiICACIiIiIiIgA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn\"\n    },\n    \"image2\": {\n        \"data\": \"hwQgABAAAAAAZmZmZmZmAGBmZmZmZmYGZmZmZmZmZmZmZv9vZm9mZmZmb/Zmb2ZmZmZvZv9vZmZmZmZmZmZmZmZmb2ZmZmZmZmZvZmZmZmZmZv///29mZmZmb2ZmZmZmZmZvZmZmZmZmZmZmZmZmZmZmZvb/b2ZmZmb2b29mZmZmZm9mb2ZmZmZm9m9vZmZmZmZm9v9vZmZmZmZmZmZmZmZm////b2ZmZmZv9mZmZmZmZm/2b2ZmZmZm9m/2b2ZmZmZmZmZmZmZmZm9mZmZmZmZmb2ZmZmZmZmb///9vZmZmZm9mZmZmZmZmb2ZmZmZmZmZmZmZmZmZgZmZmZmZmBgBmZmZmZmYA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}"},{"type":"added","filename":"images.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myImages {\n\n    helpers._registerFactory(\"image\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"image1\":\n            case \"StartBtn\":return img`\n..8888888888888888888888888888..\n.888888888888888888888888888888.\n88888888888888888888888888888888\n88888888888888888888888888888888\n888fff8fffff888f888fff88fffff888\n888f88888f8888f8f88f88f888f88888\n888f88888f8888f8f88f88f888f88888\n8888f8888f888f888f8fff8888f88888\n88888f888f888fffff8f8f8888f88888\n88888f888f888f888f8f88f888f88888\n888fff888f888f888f8f88f888f88888\n88888888888888888888888888888888\n88888888888888888888888888888888\n88888888888888888888888888888888\n.888888888888888888888888888888.\n..8888888888888888888888888888..\n`;\n            case \"image2\":\n            case \"StartBtn0\":return img`\n..6666666666666666666666666666..\n.666666666666666666666666666666.\n66666666666666666666666666666666\n66666666666666666666666666666666\n666fff6fffff666f666fff66fffff666\n666f66666f6666f6f66f66f666f66666\n666f66666f6666f6f66f66f666f66666\n6666f6666f666f666f6fff6666f66666\n66666f666f666fffff6f6f6666f66666\n66666f666f666f666f6f66f666f66666\n666fff666f666f666f6f66f666f66666\n66666666666666666666666666666666\n66666666666666666666666666666666\n66666666666666666666666666666666\n.666666666666666666666666666666.\n..6666666666666666666666666666..\n`;\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"animation\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"song\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"}]},{"timestamp":1745977727252,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":6051,"length1":87,"diffs":[[1,"        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, true);\n"]]}]}]},{"timestamp":1745978431137,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":443,"length1":46,"diffs":[[1,"        setOnSelect: (fn: ()=> void) => void;\n"]]}]}]},{"timestamp":1745978493225,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":443,"length1":166,"diffs":[[1,"        setOnSelect: (fn: ()=> void) => Menu;\n        setOnHighlight: (fn: ()=>void) => void;\n        setOnUnhighlight: (fn: ()=> void) => void;\n"]]},{"start1":1184,"length1":179,"diffs":[[1,""]]},{"start1":1690,"length1":107,"diffs":[[1,"            onSelect: undefined,\n            onHighlight: undefined,\n            onUnhighlight: undefined,\n            setOnSelect: (fn: () => void) => {\n                btn.onSelect = fn;\n"]]},{"start1":1894,"length1":113,"diffs":[[1,"            setOnHighlight: (fn: ()=> void)=> {\n                btn.onHighlight = fn;\n"]]},{"start1":1995,"length1":117,"diffs":[[1,"            setOnUnhighlight: (fn: ()=> void)=>{\n                btn.onUnhighlight = fn;\n"]]},{"start1":2098,"length1":11,"diffs":[[1,"        }\n"]]}]}]},{"timestamp":1745979042591,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":443,"length1":0,"diffs":[[1,"        setOnSelect?: (fn: ()=> void) => MenuButton;\n        setOnHighlight?: (fn: ()=>void) => MenuButton;\n        setOnUnhighlight?: (fn: ()=> void) => MenuButton;\n"]]},{"start1":1828,"length1":17,"diffs":[[1,"        const btn: MenuButton = {\n"]]},{"start1":1890,"length1":0,"diffs":[[1,"            setOnSelect(fn: () => void) {\n                this.onSelect = fn;\n                return this;\n            },\n            setOnHighlight(fn: () => void) {\n                this.onHighlight = fn;\n                return this;\n            },\n            setOnUnhighlight(fn: () => void) {\n                this.onUnhighlight = fn;\n                return this;\n            }\n"]]},{"start1":2282,"length1":0,"diffs":[[1,"        return btn;\n"]]}]}]},{"timestamp":1745979757787,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":1558,"length1":67,"diffs":[[1,"\n"]]},{"start1":1564,"length1":8,"diffs":[[1,""]]}]}]},{"timestamp":1745980020964,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":443,"length1":19,"diffs":[[1,""]]},{"start1":1558,"length1":0,"diffs":[[1,"controller.player1.onEvent(ControllerEvent.Connected, function() {\n"]]},{"start1":1630,"length1":87,"diffs":[[1,"})\n"]]}]}]},{"timestamp":1745980620225,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":443,"length1":155,"diffs":[[1,"        onSelect()\n"]]},{"start1":1772,"length1":34,"diffs":[[1,"        return {\n"]]},{"start1":1817,"length1":773,"diffs":[[1,""]]},{"start1":1828,"length1":21,"diffs":[[1,""]]}]}]},{"timestamp":1745981218901,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":1908,"length1":39,"diffs":[[1,"        const btn: MenuButton = {\n            sprite: sprite,\n"]]},{"start1":1971,"length1":151,"diffs":[[1,"            // Initialize these as methods, but we'll explicitly bind them to `btn`\n            onSelect: function() { },\n            onHighlight() { },\n            onUnhighlight() { },\n"]]},{"start1":2158,"length1":130,"diffs":[[1,"            setOnSelect(fn: () => void): MenuButton {\n                this.onSelect = fn.bind(this);  // Bind the function to the button instance\n                return this;\n            },\n            setOnHighlight(fn: () => void): MenuButton {\n                this.onHighlight = fn.bind(this);  // Bind the function to the button instance\n                return this;\n            },\n            setOnUnhighlight(fn: () => void): MenuButton {\n                this.onUnhighlight = fn.bind(this);  // Bind the function to the button instance\n                return this;\n            }\n"]]},{"start1":2755,"length1":323,"diffs":[[1,"        return btn;\n"]]},{"start1":2782,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1745981738200,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":179,"length1":35,"diffs":[[1,"    export interface MenuButton {\n"]]},{"start1":342,"length1":116,"diffs":[[1,"        onSelect?: () => void;\n        onHighlight?: () => void;\n        onUnhighlight?: () => void;\n        setOnSelect(fn: () => void): MenuButton;\n        setOnHighlight(fn: () => void): MenuButton;\n        setOnUnhighlight(fn: () => void): MenuButton;\n"]]},{"start1":605,"length1":181,"diffs":[[1,""]]},{"start1":671,"length1":63,"diffs":[[1,"        buttons: MenuButton[]; // List of buttons in the menu\n"]]},{"start1":1224,"length1":52,"diffs":[[1,"    let globalOnSelect: (btn: MenuButton) => void;\n"]]},{"start1":1276,"length1":62,"diffs":[[1,"    export function onSelect(fn: (btn: MenuButton) => void){\n"]]},{"start1":1718,"length1":0,"diffs":[[1,"    controller.player1.onEvent(ControllerEvent.Connected, function() {\n        \n    })\n    \n"]]},{"start1":1845,"length1":251,"diffs":[[1,"    export function createButton(sprite: Sprite): MenuButton {\n        let button = {} as MenuButton;\n"]]},{"start1":1948,"length1":0,"diffs":[[1,"        button.sprite = sprite;\n        button.onSelect = undefined;\n        button.onHighlight = undefined;\n        button.onUnhighlight = undefined;\n\n        button.setOnSelect = function (fn: () => void): MenuButton {\n            button.onSelect = fn;\n            return button;\n        };\n\n        button.setOnHighlight = function (fn: () => void): MenuButton {\n            button.onHighlight = fn;\n            return button;\n        };\n\n        button.setOnUnhighlight = function (fn: () => void): MenuButton {\n            button.onUnhighlight = fn;\n            return button;\n        };\n\n"]]},{"start1":2572,"length1":0,"diffs":[[1,"\n\n"]]},{"start1":2618,"length1":68,"diffs":[[1,"    export function addButton(menu: Menu, btn: MenuButton): void {\n"]]},{"start1":4496,"length1":73,"diffs":[[1,"        if(selectedBtn.onHighlight) selectedBtn.onHighlight();\n"]]},{"start1":6221,"length1":64,"diffs":[[1,"        if (selected.onSelect) selected.onSelect();\n"]]}]}]},{"timestamp":1746839843686,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":542,"length1":9,"diffs":[[1,"\n"]]}]}]},{"timestamp":1746840018608,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":542,"length1":1,"diffs":[[1,"        \n"]]},{"start1":630,"length1":274,"diffs":[[1,""]]},{"start1":639,"length1":0,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1746840410827,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":179,"length1":0,"diffs":[[1,"    export interface IMenuButton {\n        sprite: Sprite; // The button's sprite (visual representation on screen)\n        // Callback Events (? denotes optional)\n        selectHandler?: () => void;\n        highlightHandler?: () => void;\n        unhighlightHandler?: () => void;\n    }\n"]]},{"start1":466,"length1":29,"diffs":[[1,"    export class MenuButton implements IMenuButton{\n"]]},{"start1":649,"length1":34,"diffs":[[1,"            return this.sprite.y;\n"]]},{"start1":725,"length1":35,"diffs":[[1,"            this.sprite.y = value;\n"]]},{"start1":842,"length1":66,"diffs":[[1,"        set y(velue: number) {\n            \n"]]}]}]},{"timestamp":1746840898235,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":618,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1746843397079,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":618,"length1":17,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1746843405363,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":233,"length1":37,"diffs":[[1,"\n"]]},{"start1":618,"length1":1,"diffs":[[1,"        function\n"]]}]}]},{"timestamp":1746843866871,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":233,"length1":88,"diffs":[[1,"        // select, deselect, confirm\n"]]},{"start1":654,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1746844281497,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":705,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1746846033989,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":705,"length1":11,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1746846109492,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":179,"length1":0,"diffs":[[1,"\n"]]},{"start1":705,"length1":224,"diffs":[[1,"        fu\n"]]},{"start1":789,"length1":62,"diffs":[[1,"        buttons: IMenuButton[]; // List of buttons in the menu\n"]]},{"start1":1343,"length1":51,"diffs":[[1,"    let globalOnSelect: (btn: IMenuButton) => void;\n"]]},{"start1":1396,"length1":61,"diffs":[[1,"    export function onSelect(fn: (btn: IMenuButton) => void){\n"]]}]}]},{"timestamp":1746846683744,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":934,"length1":36,"diffs":[[1,"\n"]]}]}]},{"timestamp":1746847441031,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":934,"length1":1,"diffs":[[1,"controller.player1.moveSprite(null)\n"]]}]}]},{"timestamp":1746847452675,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"menus.ts","patch":[{"start1":934,"length1":5,"diffs":[[1,"\n"]]}]}]},{"timestamp":1746847468842,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":389,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable type=\"KIND_SpriteKind\" id=\"bazA5/H{+u}Tj2(:kKHf\">Player</variable><variable type=\"KIND_SpriteKind\" id=\")c8=tFp{SEW[,cK.qyE6\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"g098*iIQwzmV]O}W;jLo\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"A|e?Q%Gm%9?1SlqqpmEg\">Enemy</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"spritesoncreated\" x=\"179\" y=\"276\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"268\" y=\"450\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block><block type=\"spritesoncreated\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"168\" y=\"521\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\" disabled-reasons=\"MANUALLY_DISABLED\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"241\" y=\"657\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></xml>"]]}]}]},{"timestamp":1746853527184,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":322,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1745391880917,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1745395699840,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n","README.md":" ","assets.json":"","text.ts":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}","menus.ts":"//% color=\"#b527c4\" icon=\"\\uf00b\"\n//% advanced=true\nnamespace menus {\n    \n    //% block\n    export function test() {\n\n    }\n}","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"text.ts\",\n        \"menus.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1745642789741,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n","README.md":" ","assets.json":"","text.ts":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}","menus.ts":"//% color=\"#b527c4\" icon=\"\\uf00b\"\n//% advanced=true\nnamespace menus {\n\n    /**\n     * Things a menu will need:\n     * Buttons\n     * Screens\n     * States\n     * Contextual actions\n     * Displays\n     */\n\n\n    //% block\n    export function test() {\n\n    }\n}","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"text.ts\",\n        \"menus.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1745981599137,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable type=\"KIND_SpriteKind\" id=\"bazA5/H{+u}Tj2(:kKHf\">Player</variable><variable type=\"KIND_SpriteKind\" id=\")c8=tFp{SEW[,cK.qyE6\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"g098*iIQwzmV]O}W;jLo\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"A|e?Q%Gm%9?1SlqqpmEg\">Enemy</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"spritesoncreated\" x=\"179\" y=\"276\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"268\" y=\"450\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block><block type=\"spritesoncreated\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"168\" y=\"521\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\" disabled-reasons=\"MANUALLY_DISABLED\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"241\" y=\"657\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></xml>","main.ts":"","README.md":" ","assets.json":"","text.ts":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}","menus.ts":"// Menus.ts - Extension Helper for Menu Screens\n\n//% color=\"#b527c4\" icon=\"\\uf00b\"\n//% advanced=true\nnamespace menus {\n    // Define the structure of a single button in the menus\n    export interface MenuButton {\n        sprite: Sprite; // The button's sprite (visual representation on screen)\n        // Callback Events (? denotes optional)\n        onSelect?: () => void;\n        onHighlight?: () => void;\n        onUnhighlight?: () => void;\n        setOnSelect(fn: () => void): MenuButton;\n        setOnHighlight(fn: () => void): MenuButton;\n        setOnUnhighlight(fn: () => void): MenuButton;\n    }\n\n    // Define the structure of a menu\n    export interface Menu {\n        buttons: MenuButton[]; // List of buttons in the menu\n        selectedIndex: number; // Track index of currently selected button\n        active: boolean; // Track state of menu (visible on screen)\n        cursorSprite?: Sprite; // Optional sprite that visually indicates the selected button\n        onLayoutUpdate?: (menu: Menu) => void; // Optional callback to update the layout when the selection changes\n        usePositionNavigation?: boolean; // Optional toggle for navigation based on button positions\n    }\n\n    // Global event listeners\n    let globalOnSelect: (btn: MenuButton) => void;\n\n    export function onSelect(fn: (btn: MenuButton) => void){\n        globalOnSelect = fn;\n    }\n\n    // Function to create a menu\n    export function createMenu(): Menu {\n        return {\n            buttons: [],\n            selectedIndex: 0, // Start with the first button selected\n            active: true, // Menu is active (visible)\n            usePositionNavigation: false // Default to using index-based navigation\n        }\n    }\n    \n    controller.player1.onEvent(ControllerEvent.Connected, function() {\n        \n    })\n    \n    // Function to create a button\n    export function createButton(sprite: Sprite): MenuButton {\n        // Initialize the button object\n        const btn: MenuButton = {\n            sprite: sprite,\n            onSelect: () => { },  // Default empty function\n            onHighlight: () => { },\n            onUnhighlight: () => { },\n\n            // Methods to set custom callbacks\n            setOnSelect(fn: () => void): MenuButton {\n                // Check if function is valid\n                if (typeof fn !== 'function') {\n                    console.error('onSelect must be a function!');\n                    return this;\n                }\n                this.onSelect = fn;  // Assign the function\n                return this;\n            },\n            setOnHighlight(fn: () => void): MenuButton {\n                if (typeof fn !== 'function') {\n                    console.error('onHighlight must be a function!');\n                    return this;\n                }\n                this.onHighlight = fn;  // Assign the function\n                return this;\n            },\n            setOnUnhighlight(fn: () => void): MenuButton {\n                if (typeof fn !== 'function') {\n                    console.error('onUnhighlight must be a function!');\n                    return this;\n                }\n                this.onUnhighlight = fn;  // Assign the function\n                return this;\n            }\n        };\n\n        // Return the button object\n        return btn;\n    }\n\n    // Example usage:\n\n    // Create a button\n    const myButton = createButton(sprites.create(img`\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n    `,SpriteKind.Player));\n\n    // Set custom functions\n    myButton.setOnSelect(() => {\n        console.log('Button Selected');\n        // Ensure 'this' context is correct\n        console.log(this);  // Should print the button object\n    });\n\n    // Call the function to see if it works\n    myButton.onSelect();  // Should work if everything is correctly bound\n    // Function to add a button to a menuUI\n    export function addButton(menu: Menu, btn: MenuButton): void {\n        menu.buttons.push(btn);\n    }\n\n    // Function to update the currently selected button in the Menu\n    export function updateSelection(menu: Menu, direction: number | { x: number, y: number}){\n        //Check if we are able to update selection\n        if(!menu.active||menu.buttons.length===0) return;\n\n        const current = menu.buttons[menu.selectedIndex];\n\n        if (current.onUnhighlight) current.onUnhighlight();\n\n        if (menu.usePositionNavigation && typeof direction !== \"number\"){\n            // If we should navigate buttons based on coordinate positions\n            updateSelectionByPosition(menu, direction);\n        } else if (typeof direction === \"number\") {\n            //If we should navigate buttons through the array with index\n            const total = menu.buttons.length;\n            menu.selectedIndex = (menu.selectedIndex + direction + total) % total;\n            //MATH BREAKDOWN\n            /**\n             * selectedIndex is the current index of the selected button in the array of buttons.\n             * we add the direction to the selectedIndex to move up or down the list of buttons.\n             * we also add the total number of buttons to make sure the result is positive \n             * even if the index + direction would go negative. \n             * Ex: if we're at index 0 and move -1, we'd be at button number -1 which is invalid.\n             * we use the modulo operator (%) to wrap the index around the range of our array,\n             * Ex: (3 + 1 + 3) % 3 = (7) % 3 = 1\n             */\n        }\n\n        // Track new button\n        const selectedBtn = menu.buttons[menu.selectedIndex];\n\n        //If using sprite cursor\n        if (menu.cursorSprite){\n            menu.cursorSprite.setPosition(selectedBtn.sprite.x, selectedBtn.sprite.y);\n        }\n\n        if(selectedBtn.onHighlight) selectedBtn.onHighlight();\n        if(menu.onLayoutUpdate) menu.onLayoutUpdate(menu);\n    }\n\n    // Function to update the selection based on relative position of the buttons\n    function updateSelectionByPosition(menu: Menu, dir: {x: number, y: number}){\n        const current = menu.buttons[menu.selectedIndex].sprite;\n        let closestIndex = menu.selectedIndex;\n        let closestScore = -Infinity;\n\n        for (let i = 0; i < menu.buttons.length; i++){\n            // Skip selected button\n            if (i === menu.selectedIndex) continue;\n\n            // Calculate distance with pythag\n            const other = menu.buttons[i].sprite;\n            const dx = other.x - current.x;\n            const dy = other.y - current.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist === 0) continue;\n\n            const normDX = dx / dist;\n            const normDY = dy / dist;\n\n            // Dot product to measure how well aligned the two vectors are\n            const dot = normDX * dir.x + normDY * dir.y;\n            // skip buttons that aren't in the intended direction\n            if (dot <= 0.1) continue;\n            // add penalty for distance\n            const score = dot - (dist * 0.01)\n\n            if (score > closestScore) {\n                closestScore = score;\n                closestIndex = i;\n            }\n        }\n        \n        menu.selectedIndex = closestIndex;\n    }\n\n    // Function to confirm the selection of the currently selected buttons\n    export function confirm(menu: Menu) {\n        if (!menu.active) return;\n\n        const selected = menu.buttons[menu.selectedIndex];\n\n        // if we have on selected event, trigger it.\n        if (selected.onSelect) selected.onSelect();\n    }\n\n    // Function to show the Menu\n    export function show(menu: Menu){\n        menu.active = true;\n        for (let btn of menu.buttons) {\n            btn.sprite.setFlag(SpriteFlag.Invisible, false);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n\n    // Function to hide the Menu\n    export function hide(menu: Menu) {\n        menu.active = false;\n        for (let btn of menu.buttons){\n            btn.sprite.setFlag(SpriteFlag.Invisible, true);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n\n    // Function to destroy the menu and clean up\n    export function destroy(menu: Menu) {\n        for (let btn of menu.buttons) {\n            sprites.destroy(btn.sprite);\n            }\n        if (menu.cursorSprite) {\n            menu.cursorSprite.destroy();\n            \n        }\n        menu.active = false;\n    }\n}","vectorMath.ts":"// Add your code here\n\nnamespace Math {\n    // Define a 2D vector structure\n    export type Vector2 = { x: number; y: number }\n\n    // Predefined directional vectors\n    export const Vector2 = {\n        up: { x: 0, y: -1 },\n        down: { x: 0, y: 1 },\n        left: { x: -1, y: 0 },\n        right: { x: 1, y: 0 },\n        zero: { x: 0, y: 0 },\n        one: { x: 1, y: 1 },\n\n        // Optional: utility functions\n        add: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x + b.x, y: a.y + b.y }),\n        sub: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x - b.x, y: a.y - b.y }),\n        scale: (v: Vector2, s: number): Vector2 => ({ x: v.x * s, y: v.y * s }),\n        dot: (a: Vector2, b: Vector2): number => a.x * b.x + a.y * b.y,\n        magnitude: (v: Vector2): number => Math.sqrt(v.x * v.x + v.y * v.y),\n        normalize: (v: Vector2): Vector2 => {\n            const mag = Vector2.magnitude(v)\n            return mag === 0 ? Vector2.zero : { x: v.x / mag, y: v.y / mag }\n        }\n    }\n}\n","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQgABAAAAAAiIiIiIiIAICIiIiIiIgIiIiIiIiIiIiIiP+PiI+IiIiIj/iIj4iIiIiPiP+PiIiIiIiIiIiIiIiIj4iIiIiIiIiPiIiIiIiIiP///4+IiIiIj4iIiIiIiIiPiIiIiIiIiIiIiIiIiIiIiPj/j4iIiIj4j4+IiIiIiI+Ij4iIiIiI+I+PiIiIiIiI+P+PiIiIiIiIiIiIiIiI////j4iIiIiP+IiIiIiIiI/4j4iIiIiI+I/4j4iIiIiIiIiIiIiIiI+IiIiIiIiIj4iIiIiIiIj///+PiIiIiI+IiIiIiIiIj4iIiIiIiIiIiIiIiIiAiIiIiIiICACIiIiIiIgA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn\"\n    },\n    \"image2\": {\n        \"data\": \"hwQgABAAAAAAZmZmZmZmAGBmZmZmZmYGZmZmZmZmZmZmZv9vZm9mZmZmb/Zmb2ZmZmZvZv9vZmZmZmZmZmZmZmZmb2ZmZmZmZmZvZmZmZmZmZv///29mZmZmb2ZmZmZmZmZvZmZmZmZmZmZmZmZmZmZmZvb/b2ZmZmb2b29mZmZmZm9mb2ZmZmZm9m9vZmZmZmZm9v9vZmZmZmZmZmZmZmZm////b2ZmZmZv9mZmZmZmZm/2b2ZmZmZm9m/2b2ZmZmZmZmZmZmZmZm9mZmZmZmZmb2ZmZmZmZmb///9vZmZmZm9mZmZmZmZmb2ZmZmZmZmZmZmZmZmZgZmZmZmZmBgBmZmZmZmYA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"text.ts\",\n        \"menus.ts\",\n        \"vectorMath.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1746839843686,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable type=\"KIND_SpriteKind\" id=\"bazA5/H{+u}Tj2(:kKHf\">Player</variable><variable type=\"KIND_SpriteKind\" id=\")c8=tFp{SEW[,cK.qyE6\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"g098*iIQwzmV]O}W;jLo\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"A|e?Q%Gm%9?1SlqqpmEg\">Enemy</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"spritesoncreated\" x=\"179\" y=\"276\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"268\" y=\"450\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block><block type=\"spritesoncreated\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"168\" y=\"521\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\" disabled-reasons=\"MANUALLY_DISABLED\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"241\" y=\"657\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></xml>","main.ts":"","README.md":" ","assets.json":"","text.ts":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}","menus.ts":"// Menus.ts - Extension Helper for Menu Screens\n\n//% color=\"#b527c4\" icon=\"\\uf00b\"\n//% advanced=true\nnamespace menus {\n    // Define the structure of a single button in the menus\n    export interface MenuButton {\n        sprite: Sprite; // The button's sprite (visual representation on screen)\n        // Callback Events (? denotes optional)\n        onSelect?: () => void;\n        onHighlight?: () => void;\n        onUnhighlight?: () => void;\n        setOnSelect(fn: () => void): MenuButton;\n        setOnHighlight(fn: () => void): MenuButton;\n        setOnUnhighlight(fn: () => void): MenuButton;\n    }\n\n    // Define the structure of a menu\n    export interface Menu {\n        buttons: MenuButton[]; // List of buttons in the menu\n        selectedIndex: number; // Track index of currently selected button\n        active: boolean; // Track state of menu (visible on screen)\n        cursorSprite?: Sprite; // Optional sprite that visually indicates the selected button\n        onLayoutUpdate?: (menu: Menu) => void; // Optional callback to update the layout when the selection changes\n        usePositionNavigation?: boolean; // Optional toggle for navigation based on button positions\n    }\n\n    // Global event listeners\n    let globalOnSelect: (btn: MenuButton) => void;\n\n    export function onSelect(fn: (btn: MenuButton) => void){\n        globalOnSelect = fn;\n    }\n\n    // Function to create a menu\n    export function createMenu(): Menu {\n        return {\n            buttons: [],\n            selectedIndex: 0, // Start with the first button selected\n            active: true, // Menu is active (visible)\n            usePositionNavigation: false // Default to using index-based navigation\n        }\n    }\n    \n    controller.player1.onEvent(ControllerEvent.Connected, function() {\n        \n    })\n    \n    // Function to create a button\n    export function createButton(sprite: Sprite): MenuButton {\n        let button = {} as MenuButton;\n\n        button.sprite = sprite;\n        button.onSelect = undefined;\n        button.onHighlight = undefined;\n        button.onUnhighlight = undefined;\n\n        button.setOnSelect = function (fn: () => void): MenuButton {\n            button.onSelect = fn;\n            return button;\n        };\n\n        button.setOnHighlight = function (fn: () => void): MenuButton {\n            button.onHighlight = fn;\n            return button;\n        };\n\n        button.setOnUnhighlight = function (fn: () => void): MenuButton {\n            button.onUnhighlight = fn;\n            return button;\n        };\n\n        return button;\n    }\n\n\n\n    // Function to add a button to a menuUI\n    export function addButton(menu: Menu, btn: MenuButton): void {\n        menu.buttons.push(btn);\n    }\n\n    // Function to update the currently selected button in the Menu\n    export function updateSelection(menu: Menu, direction: number | { x: number, y: number}){\n        //Check if we are able to update selection\n        if(!menu.active||menu.buttons.length===0) return;\n\n        const current = menu.buttons[menu.selectedIndex];\n\n        if (current.onUnhighlight) current.onUnhighlight();\n\n        if (menu.usePositionNavigation && typeof direction !== \"number\"){\n            // If we should navigate buttons based on coordinate positions\n            updateSelectionByPosition(menu, direction);\n        } else if (typeof direction === \"number\") {\n            //If we should navigate buttons through the array with index\n            const total = menu.buttons.length;\n            menu.selectedIndex = (menu.selectedIndex + direction + total) % total;\n            //MATH BREAKDOWN\n            /**\n             * selectedIndex is the current index of the selected button in the array of buttons.\n             * we add the direction to the selectedIndex to move up or down the list of buttons.\n             * we also add the total number of buttons to make sure the result is positive \n             * even if the index + direction would go negative. \n             * Ex: if we're at index 0 and move -1, we'd be at button number -1 which is invalid.\n             * we use the modulo operator (%) to wrap the index around the range of our array,\n             * Ex: (3 + 1 + 3) % 3 = (7) % 3 = 1\n             */\n        }\n\n        // Track new button\n        const selectedBtn = menu.buttons[menu.selectedIndex];\n\n        //If using sprite cursor\n        if (menu.cursorSprite){\n            menu.cursorSprite.setPosition(selectedBtn.sprite.x, selectedBtn.sprite.y);\n        }\n\n        if(selectedBtn.onHighlight) selectedBtn.onHighlight();\n        if(menu.onLayoutUpdate) menu.onLayoutUpdate(menu);\n    }\n\n    // Function to update the selection based on relative position of the buttons\n    function updateSelectionByPosition(menu: Menu, dir: {x: number, y: number}){\n        const current = menu.buttons[menu.selectedIndex].sprite;\n        let closestIndex = menu.selectedIndex;\n        let closestScore = -Infinity;\n\n        for (let i = 0; i < menu.buttons.length; i++){\n            // Skip selected button\n            if (i === menu.selectedIndex) continue;\n\n            // Calculate distance with pythag\n            const other = menu.buttons[i].sprite;\n            const dx = other.x - current.x;\n            const dy = other.y - current.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist === 0) continue;\n\n            const normDX = dx / dist;\n            const normDY = dy / dist;\n\n            // Dot product to measure how well aligned the two vectors are\n            const dot = normDX * dir.x + normDY * dir.y;\n            // skip buttons that aren't in the intended direction\n            if (dot <= 0.1) continue;\n            // add penalty for distance\n            const score = dot - (dist * 0.01)\n\n            if (score > closestScore) {\n                closestScore = score;\n                closestIndex = i;\n            }\n        }\n        \n        menu.selectedIndex = closestIndex;\n    }\n\n    // Function to confirm the selection of the currently selected buttons\n    export function confirm(menu: Menu) {\n        if (!menu.active) return;\n\n        const selected = menu.buttons[menu.selectedIndex];\n\n        // if we have on selected event, trigger it.\n        if (selected.onSelect) selected.onSelect();\n    }\n\n    // Function to show the Menu\n    export function show(menu: Menu){\n        menu.active = true;\n        for (let btn of menu.buttons) {\n            btn.sprite.setFlag(SpriteFlag.Invisible, false);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n\n    // Function to hide the Menu\n    export function hide(menu: Menu) {\n        menu.active = false;\n        for (let btn of menu.buttons){\n            btn.sprite.setFlag(SpriteFlag.Invisible, true);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n\n    // Function to destroy the menu and clean up\n    export function destroy(menu: Menu) {\n        for (let btn of menu.buttons) {\n            sprites.destroy(btn.sprite);\n            }\n        if (menu.cursorSprite) {\n            menu.cursorSprite.destroy();\n            \n        }\n        menu.active = false;\n    }\n}","vectorMath.ts":"// Add your code here\n\nnamespace Math {\n    // Define a 2D vector structure\n    export type Vector2 = { x: number; y: number }\n\n    // Predefined directional vectors\n    export const Vector2 = {\n        up: { x: 0, y: -1 },\n        down: { x: 0, y: 1 },\n        left: { x: -1, y: 0 },\n        right: { x: 1, y: 0 },\n        zero: { x: 0, y: 0 },\n        one: { x: 1, y: 1 },\n\n        // Optional: utility functions\n        add: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x + b.x, y: a.y + b.y }),\n        sub: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x - b.x, y: a.y - b.y }),\n        scale: (v: Vector2, s: number): Vector2 => ({ x: v.x * s, y: v.y * s }),\n        dot: (a: Vector2, b: Vector2): number => a.x * b.x + a.y * b.y,\n        magnitude: (v: Vector2): number => Math.sqrt(v.x * v.x + v.y * v.y),\n        normalize: (v: Vector2): Vector2 => {\n            const mag = Vector2.magnitude(v)\n            return mag === 0 ? Vector2.zero : { x: v.x / mag, y: v.y / mag }\n        }\n    }\n}\n","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQgABAAAAAAiIiIiIiIAICIiIiIiIgIiIiIiIiIiIiIiP+PiI+IiIiIj/iIj4iIiIiPiP+PiIiIiIiIiIiIiIiIj4iIiIiIiIiPiIiIiIiIiP///4+IiIiIj4iIiIiIiIiPiIiIiIiIiIiIiIiIiIiIiPj/j4iIiIj4j4+IiIiIiI+Ij4iIiIiI+I+PiIiIiIiI+P+PiIiIiIiIiIiIiIiI////j4iIiIiP+IiIiIiIiI/4j4iIiIiI+I/4j4iIiIiIiIiIiIiIiI+IiIiIiIiIj4iIiIiIiIj///+PiIiIiI+IiIiIiIiIj4iIiIiIiIiIiIiIiIiAiIiIiIiICACIiIiIiIgA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn\"\n    },\n    \"image2\": {\n        \"data\": \"hwQgABAAAAAAZmZmZmZmAGBmZmZmZmYGZmZmZmZmZmZmZv9vZm9mZmZmb/Zmb2ZmZmZvZv9vZmZmZmZmZmZmZmZmb2ZmZmZmZmZvZmZmZmZmZv///29mZmZmb2ZmZmZmZmZvZmZmZmZmZmZmZmZmZmZmZvb/b2ZmZmb2b29mZmZmZm9mb2ZmZmZm9m9vZmZmZmZm9v9vZmZmZmZmZmZmZmZm////b2ZmZmZv9mZmZmZmZm/2b2ZmZmZm9m/2b2ZmZmZmZmZmZmZmZm9mZmZmZmZmb2ZmZmZmZmb///9vZmZmZm9mZmZmZmZmb2ZmZmZmZmZmZmZmZmZgZmZmZmZmBgBmZmZmZmYA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"text.ts\",\n        \"menus.ts\",\n        \"vectorMath.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1746843397079,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable type=\"KIND_SpriteKind\" id=\"bazA5/H{+u}Tj2(:kKHf\">Player</variable><variable type=\"KIND_SpriteKind\" id=\")c8=tFp{SEW[,cK.qyE6\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"g098*iIQwzmV]O}W;jLo\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"A|e?Q%Gm%9?1SlqqpmEg\">Enemy</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"spritesoncreated\" x=\"179\" y=\"276\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"268\" y=\"450\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block><block type=\"spritesoncreated\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"168\" y=\"521\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\" disabled-reasons=\"MANUALLY_DISABLED\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"241\" y=\"657\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></xml>","main.ts":"","README.md":" ","assets.json":"","text.ts":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}","menus.ts":"// Menus.ts - Extension Helper for Menu Screens\n\n//% color=\"#b527c4\" icon=\"\\uf00b\"\n//% advanced=true\nnamespace menus {\n    // Define the structure of a single button in the menus\n\n    export class MenuButton{\n        sprite: Sprite;\n\n        constructor(sprite: Sprite){\n            this.sprite=sprite;\n        }\n\n        get x(): number {\n            return this.sprite.x;\n        }\n\n        set x(value: number) {\n            this.sprite.x = value;\n        }\n\n        get y(): number {\n            return this.sprite.y;\n        }\n\n        set y(value: number) {\n            this.sprite.y = value;\n        }\n        \n    }\n\n    // Define the structure of a menu\n    export interface Menu {\n        buttons: IMenuButton[]; // List of buttons in the menu\n        selectedIndex: number; // Track index of currently selected button\n        active: boolean; // Track state of menu (visible on screen)\n        cursorSprite?: Sprite; // Optional sprite that visually indicates the selected button\n        onLayoutUpdate?: (menu: Menu) => void; // Optional callback to update the layout when the selection changes\n        usePositionNavigation?: boolean; // Optional toggle for navigation based on button positions\n    }\n\n    // Global event listeners\n    let globalOnSelect: (btn: IMenuButton) => void;\n\n    export function onSelect(fn: (btn: IMenuButton) => void){\n        globalOnSelect = fn;\n    }\n\n    // Function to create a menu\n    export function createMenu(): Menu {\n        return {\n            buttons: [],\n            selectedIndex: 0, // Start with the first button selected\n            active: true, // Menu is active (visible)\n            usePositionNavigation: false // Default to using index-based navigation\n        }\n    }\n    \n    // Function to create a button\n    export function createButton(sprite: Sprite): IMenuButton {\n        let button: IMenuButton = {\n            sprite: sprite,\n            selectHandler: () => {},\n            highlightHandler: () => {},\n            onUnhighlight: () => {}\n        }\n\n        return button;\n    }\n\n    // Function to add a button to a menuUI\n    export function addButton(menu: Menu, btn: IMenuButton): void {\n        menu.buttons.push(btn);\n    }\n\n    // Function to update the currently selected button in the Menu\n    export function updateSelection(menu: Menu, direction: number | { x: number, y: number}){\n        //Check if we are able to update selection\n        if(!menu.active||menu.buttons.length===0) return;\n\n        const current = menu.buttons[menu.selectedIndex];\n\n        if (current.onUnhighlight) current.onUnhighlight();\n\n        if (menu.usePositionNavigation && typeof direction !== \"number\"){\n            // If we should navigate buttons based on coordinate positions\n            updateSelectionByPosition(menu, direction);\n        } else if (typeof direction === \"number\") {\n            //If we should navigate buttons through the array with index\n            const total = menu.buttons.length;\n            menu.selectedIndex = (menu.selectedIndex + direction + total) % total;\n            //MATH BREAKDOWN\n            /**\n             * selectedIndex is the current index of the selected button in the array of buttons.\n             * we add the direction to the selectedIndex to move up or down the list of buttons.\n             * we also add the total number of buttons to make sure the result is positive \n             * even if the index + direction would go negative. \n             * Ex: if we're at index 0 and move -1, we'd be at button number -1 which is invalid.\n             * we use the modulo operator (%) to wrap the index around the range of our array,\n             * Ex: (3 + 1 + 3) % 3 = (7) % 3 = 1\n             */\n        }\n\n        // Track new button\n        const selectedBtn = menu.buttons[menu.selectedIndex];\n\n        //If using sprite cursor\n        if (menu.cursorSprite){\n            menu.cursorSprite.setPosition(selectedBtn.sprite.x, selectedBtn.sprite.y);\n        }\n\n        if(selectedBtn.highlightHandler) selectedBtn.highlightHandler();\n        if(menu.onLayoutUpdate) menu.onLayoutUpdate(menu);\n    }\n\n    // Function to update the selection based on relative position of the buttons\n    function updateSelectionByPosition(menu: Menu, dir: {x: number, y: number}){\n        const current = menu.buttons[menu.selectedIndex].sprite;\n        let closestIndex = menu.selectedIndex;\n        let closestScore = -Infinity;\n\n        for (let i = 0; i < menu.buttons.length; i++){\n            // Skip selected button\n            if (i === menu.selectedIndex) continue;\n\n            // Calculate distance with pythag\n            const other = menu.buttons[i].sprite;\n            const dx = other.x - current.x;\n            const dy = other.y - current.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist === 0) continue;\n\n            const normDX = dx / dist;\n            const normDY = dy / dist;\n\n            // Dot product to measure how well aligned the two vectors are\n            const dot = normDX * dir.x + normDY * dir.y;\n            // skip buttons that aren't in the intended direction\n            if (dot <= 0.1) continue;\n            // add penalty for distance\n            const score = dot - (dist * 0.01)\n\n            if (score > closestScore) {\n                closestScore = score;\n                closestIndex = i;\n            }\n        }\n        \n        menu.selectedIndex = closestIndex;\n    }\n\n    // Function to confirm the selection of the currently selected buttons\n    export function confirm(menu: Menu) {\n        if (!menu.active) return;\n\n        const selected = menu.buttons[menu.selectedIndex];\n\n        // if we have on selected event, trigger it.\n        if (selected.selectHandler()) selected.selectHandler();\n    }\n\n    // Function to show the Menu\n    export function show(menu: Menu){\n        menu.active = true;\n        for (let btn of menu.buttons) {\n            btn.sprite.setFlag(SpriteFlag.Invisible, false);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n\n    // Function to hide the Menu\n    export function hide(menu: Menu) {\n        menu.active = false;\n        for (let btn of menu.buttons){\n            btn.sprite.setFlag(SpriteFlag.Invisible, true);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n\n    // Function to destroy the menu and clean up\n    export function destroy(menu: Menu) {\n        for (let btn of menu.buttons) {\n            sprites.destroy(btn.sprite);\n            }\n        if (menu.cursorSprite) {\n            menu.cursorSprite.destroy();\n            \n        }\n        menu.active = false;\n    }\n}","vectorMath.ts":"// Add your code here\n\nnamespace Math {\n    // Define a 2D vector structure\n    export type Vector2 = { x: number; y: number }\n\n    // Predefined directional vectors\n    export const Vector2 = {\n        up: { x: 0, y: -1 },\n        down: { x: 0, y: 1 },\n        left: { x: -1, y: 0 },\n        right: { x: 1, y: 0 },\n        zero: { x: 0, y: 0 },\n        one: { x: 1, y: 1 },\n\n        // Optional: utility functions\n        add: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x + b.x, y: a.y + b.y }),\n        sub: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x - b.x, y: a.y - b.y }),\n        scale: (v: Vector2, s: number): Vector2 => ({ x: v.x * s, y: v.y * s }),\n        dot: (a: Vector2, b: Vector2): number => a.x * b.x + a.y * b.y,\n        magnitude: (v: Vector2): number => Math.sqrt(v.x * v.x + v.y * v.y),\n        normalize: (v: Vector2): Vector2 => {\n            const mag = Vector2.magnitude(v)\n            return mag === 0 ? Vector2.zero : { x: v.x / mag, y: v.y / mag }\n        }\n    }\n}\n","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQgABAAAAAAiIiIiIiIAICIiIiIiIgIiIiIiIiIiIiIiP+PiI+IiIiIj/iIj4iIiIiPiP+PiIiIiIiIiIiIiIiIj4iIiIiIiIiPiIiIiIiIiP///4+IiIiIj4iIiIiIiIiPiIiIiIiIiIiIiIiIiIiIiPj/j4iIiIj4j4+IiIiIiI+Ij4iIiIiI+I+PiIiIiIiI+P+PiIiIiIiIiIiIiIiI////j4iIiIiP+IiIiIiIiI/4j4iIiIiI+I/4j4iIiIiIiIiIiIiIiI+IiIiIiIiIj4iIiIiIiIj///+PiIiIiI+IiIiIiIiIj4iIiIiIiIiIiIiIiIiAiIiIiIiICACIiIiIiIgA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn\"\n    },\n    \"image2\": {\n        \"data\": \"hwQgABAAAAAAZmZmZmZmAGBmZmZmZmYGZmZmZmZmZmZmZv9vZm9mZmZmb/Zmb2ZmZmZvZv9vZmZmZmZmZmZmZmZmb2ZmZmZmZmZvZmZmZmZmZv///29mZmZmb2ZmZmZmZmZvZmZmZmZmZmZmZmZmZmZmZvb/b2ZmZmb2b29mZmZmZm9mb2ZmZmZm9m9vZmZmZmZm9v9vZmZmZmZmZmZmZmZm////b2ZmZmZv9mZmZmZmZm/2b2ZmZmZm9m/2b2ZmZmZmZmZmZmZmZm9mZmZmZmZmb2ZmZmZmZmb///9vZmZmZm9mZmZmZmZmb2ZmZmZmZmZmZmZmZmZgZmZmZmZmBgBmZmZmZmYA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"text.ts\",\n        \"menus.ts\",\n        \"vectorMath.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1746846033989,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable type=\"KIND_SpriteKind\" id=\"bazA5/H{+u}Tj2(:kKHf\">Player</variable><variable type=\"KIND_SpriteKind\" id=\")c8=tFp{SEW[,cK.qyE6\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"g098*iIQwzmV]O}W;jLo\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"A|e?Q%Gm%9?1SlqqpmEg\">Enemy</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"spritesoncreated\" x=\"179\" y=\"276\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"268\" y=\"450\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block><block type=\"spritesoncreated\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"168\" y=\"521\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\" disabled-reasons=\"MANUALLY_DISABLED\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"241\" y=\"657\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></xml>","main.ts":"","README.md":" ","assets.json":"","text.ts":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}","menus.ts":"// Menus.ts - Extension Helper for Menu Screens\n\n//% color=\"#b527c4\" icon=\"\\uf00b\"\n//% advanced=true\nnamespace menus {\n    // Define the structure of a single button in the menus\n\n    export class MenuButton{\n        sprite: Sprite;\n        onFocus?: () => void\n        onBlur?: () => void\n        onSelect?: () => void\n\n        constructor(sprite: Sprite){\n            this.sprite=sprite;\n        }\n\n        get x(): number {\n            return this.sprite.x;\n        }\n\n        set x(value: number) {\n            this.sprite.x = value;\n        }\n\n        get y(): number {\n            return this.sprite.y;\n        }\n\n        set y(value: number) {\n            this.sprite.y = value;\n        }\n        \n    }\n\n    // Define the structure of a menu\n    export interface Menu {\n        buttons: IMenuButton[]; // List of buttons in the menu\n        selectedIndex: number; // Track index of currently selected button\n        active: boolean; // Track state of menu (visible on screen)\n        cursorSprite?: Sprite; // Optional sprite that visually indicates the selected button\n        onLayoutUpdate?: (menu: Menu) => void; // Optional callback to update the layout when the selection changes\n        usePositionNavigation?: boolean; // Optional toggle for navigation based on button positions\n    }\n\n    // Global event listeners\n    let globalOnSelect: (btn: IMenuButton) => void;\n\n    export function onSelect(fn: (btn: IMenuButton) => void){\n        globalOnSelect = fn;\n    }\n\n    // Function to create a menu\n    export function createMenu(): Menu {\n        return {\n            buttons: [],\n            selectedIndex: 0, // Start with the first button selected\n            active: true, // Menu is active (visible)\n            usePositionNavigation: false // Default to using index-based navigation\n        }\n    }\n    \n    // Function to create a button\n    export function createButton(sprite: Sprite): IMenuButton {\n        let button: IMenuButton = {\n            sprite: sprite,\n            selectHandler: () => {},\n            highlightHandler: () => {},\n            onUnhighlight: () => {}\n        }\n\n        return button;\n    }\n\n    // Function to add a button to a menuUI\n    export function addButton(menu: Menu, btn: IMenuButton): void {\n        menu.buttons.push(btn);\n    }\n\n    // Function to update the currently selected button in the Menu\n    export function updateSelection(menu: Menu, direction: number | { x: number, y: number}){\n        //Check if we are able to update selection\n        if(!menu.active||menu.buttons.length===0) return;\n\n        const current = menu.buttons[menu.selectedIndex];\n\n        if (current.onUnhighlight) current.onUnhighlight();\n\n        if (menu.usePositionNavigation && typeof direction !== \"number\"){\n            // If we should navigate buttons based on coordinate positions\n            updateSelectionByPosition(menu, direction);\n        } else if (typeof direction === \"number\") {\n            //If we should navigate buttons through the array with index\n            const total = menu.buttons.length;\n            menu.selectedIndex = (menu.selectedIndex + direction + total) % total;\n            //MATH BREAKDOWN\n            /**\n             * selectedIndex is the current index of the selected button in the array of buttons.\n             * we add the direction to the selectedIndex to move up or down the list of buttons.\n             * we also add the total number of buttons to make sure the result is positive \n             * even if the index + direction would go negative. \n             * Ex: if we're at index 0 and move -1, we'd be at button number -1 which is invalid.\n             * we use the modulo operator (%) to wrap the index around the range of our array,\n             * Ex: (3 + 1 + 3) % 3 = (7) % 3 = 1\n             */\n        }\n\n        // Track new button\n        const selectedBtn = menu.buttons[menu.selectedIndex];\n\n        //If using sprite cursor\n        if (menu.cursorSprite){\n            menu.cursorSprite.setPosition(selectedBtn.sprite.x, selectedBtn.sprite.y);\n        }\n\n        if(selectedBtn.highlightHandler) selectedBtn.highlightHandler();\n        if(menu.onLayoutUpdate) menu.onLayoutUpdate(menu);\n    }\n\n    // Function to update the selection based on relative position of the buttons\n    function updateSelectionByPosition(menu: Menu, dir: {x: number, y: number}){\n        const current = menu.buttons[menu.selectedIndex].sprite;\n        let closestIndex = menu.selectedIndex;\n        let closestScore = -Infinity;\n\n        for (let i = 0; i < menu.buttons.length; i++){\n            // Skip selected button\n            if (i === menu.selectedIndex) continue;\n\n            // Calculate distance with pythag\n            const other = menu.buttons[i].sprite;\n            const dx = other.x - current.x;\n            const dy = other.y - current.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist === 0) continue;\n\n            const normDX = dx / dist;\n            const normDY = dy / dist;\n\n            // Dot product to measure how well aligned the two vectors are\n            const dot = normDX * dir.x + normDY * dir.y;\n            // skip buttons that aren't in the intended direction\n            if (dot <= 0.1) continue;\n            // add penalty for distance\n            const score = dot - (dist * 0.01)\n\n            if (score > closestScore) {\n                closestScore = score;\n                closestIndex = i;\n            }\n        }\n        \n        menu.selectedIndex = closestIndex;\n    }\n\n    // Function to confirm the selection of the currently selected buttons\n    export function confirm(menu: Menu) {\n        if (!menu.active) return;\n\n        const selected = menu.buttons[menu.selectedIndex];\n\n        // if we have on selected event, trigger it.\n        if (selected.selectHandler()) selected.selectHandler();\n    }\n\n    // Function to show the Menu\n    export function show(menu: Menu){\n        menu.active = true;\n        for (let btn of menu.buttons) {\n            btn.sprite.setFlag(SpriteFlag.Invisible, false);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n\n    // Function to hide the Menu\n    export function hide(menu: Menu) {\n        menu.active = false;\n        for (let btn of menu.buttons){\n            btn.sprite.setFlag(SpriteFlag.Invisible, true);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n\n    // Function to destroy the menu and clean up\n    export function destroy(menu: Menu) {\n        for (let btn of menu.buttons) {\n            sprites.destroy(btn.sprite);\n            }\n        if (menu.cursorSprite) {\n            menu.cursorSprite.destroy();\n            \n        }\n        menu.active = false;\n    }\n}","vectorMath.ts":"// Add your code here\n\nnamespace Math {\n    // Define a 2D vector structure\n    export type Vector2 = { x: number; y: number }\n\n    // Predefined directional vectors\n    export const Vector2 = {\n        up: { x: 0, y: -1 },\n        down: { x: 0, y: 1 },\n        left: { x: -1, y: 0 },\n        right: { x: 1, y: 0 },\n        zero: { x: 0, y: 0 },\n        one: { x: 1, y: 1 },\n\n        // Optional: utility functions\n        add: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x + b.x, y: a.y + b.y }),\n        sub: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x - b.x, y: a.y - b.y }),\n        scale: (v: Vector2, s: number): Vector2 => ({ x: v.x * s, y: v.y * s }),\n        dot: (a: Vector2, b: Vector2): number => a.x * b.x + a.y * b.y,\n        magnitude: (v: Vector2): number => Math.sqrt(v.x * v.x + v.y * v.y),\n        normalize: (v: Vector2): Vector2 => {\n            const mag = Vector2.magnitude(v)\n            return mag === 0 ? Vector2.zero : { x: v.x / mag, y: v.y / mag }\n        }\n    }\n}\n","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQgABAAAAAAiIiIiIiIAICIiIiIiIgIiIiIiIiIiIiIiP+PiI+IiIiIj/iIj4iIiIiPiP+PiIiIiIiIiIiIiIiIj4iIiIiIiIiPiIiIiIiIiP///4+IiIiIj4iIiIiIiIiPiIiIiIiIiIiIiIiIiIiIiPj/j4iIiIj4j4+IiIiIiI+Ij4iIiIiI+I+PiIiIiIiI+P+PiIiIiIiIiIiIiIiI////j4iIiIiP+IiIiIiIiI/4j4iIiIiI+I/4j4iIiIiIiIiIiIiIiI+IiIiIiIiIj4iIiIiIiIj///+PiIiIiI+IiIiIiIiIj4iIiIiIiIiIiIiIiIiAiIiIiIiICACIiIiIiIgA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn\"\n    },\n    \"image2\": {\n        \"data\": \"hwQgABAAAAAAZmZmZmZmAGBmZmZmZmYGZmZmZmZmZmZmZv9vZm9mZmZmb/Zmb2ZmZmZvZv9vZmZmZmZmZmZmZmZmb2ZmZmZmZmZvZmZmZmZmZv///29mZmZmb2ZmZmZmZmZvZmZmZmZmZmZmZmZmZmZmZvb/b2ZmZmb2b29mZmZmZm9mb2ZmZmZm9m9vZmZmZmZm9v9vZmZmZmZmZmZmZmZm////b2ZmZmZv9mZmZmZmZm/2b2ZmZmZm9m/2b2ZmZmZmZmZmZmZmZm9mZmZmZmZmb2ZmZmZmZmb///9vZmZmZm9mZmZmZmZmb2ZmZmZmZmZmZmZmZmZgZmZmZmZmBgBmZmZmZmYA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"text.ts\",\n        \"menus.ts\",\n        \"vectorMath.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1746853527184,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable type=\"KIND_SpriteKind\" id=\"bazA5/H{+u}Tj2(:kKHf\">Player</variable><variable type=\"KIND_SpriteKind\" id=\")c8=tFp{SEW[,cK.qyE6\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"g098*iIQwzmV]O}W;jLo\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"A|e?Q%Gm%9?1SlqqpmEg\">Enemy</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"spritesoncreated\" x=\"179\" y=\"276\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"268\" y=\"450\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block><block type=\"spritesoncreated\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"168\" y=\"521\"><value name=\"HANDLER_DRAG_PARAM_sprite\"><block type=\"argument_reporter_custom\" disabled-reasons=\"MANUALLY_DISABLED\"><mutation duplicateondrag=\"true\" typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></value><value name=\"kind\"><shadow type=\"spritekind\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"MEMBER\">Player</field></shadow></value></block><block type=\"argument_reporter_custom\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"241\" y=\"657\"><mutation typename=\"Sprite\"></mutation><field name=\"VALUE\">sprite</field></block></xml>","main.ts":"","README.md":" ","assets.json":"","text.ts":"namespace images {\n    /**\n     * Print text on an image\n     */\n    //% blockId=imagesprinttext\n    //% block=\"print $picture $text at x $x y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function print(picture: Image, text: string, x: number, y: number, color: number) {\n        picture.print(text, x, y, color)\n    }\n\n    /**\n     * Print text centered on an image\n     */\n    //% blockId=imagesprinttextcenter\n    //% block=\"print $picture center $text at y $y in color $color\"\n    //% picture.defl=picture\n    //% picture.shadow=variables_get\n    //% color.shadow=colorindexpicker\n    //% group=\"Text\"\n    //% inlineInputMode=inline\n    export function printCenter(picture: Image, text: string, y: number, color: number) {\n        picture.printCenter(text, y, color)\n    }\n}","menus.ts":"// Menus.ts - Extension Helper for Menu Screens\n\n//% color=\"#b527c4\" icon=\"\\uf00b\"\n//% advanced=true\nnamespace menus {\n    // Define the structure of a single button in the menus\n    export class MenuButton{\n        sprite: Sprite;\n        onFocus?: () => void\n        onBlur?: () => void\n        onSelect?: () => void\n\n        constructor(sprite: Sprite){\n            this.sprite=sprite;\n        }\n\n        get x(): number {\n            return this.sprite.x;\n        }\n\n        set x(value: number) {\n            this.sprite.x = value;\n        }\n\n        get y(): number {\n            return this.sprite.y;\n        }\n\n        set y(value: number) {\n            this.sprite.y = value;\n        }\n        \n        Select() {\n            if (this.onSelect) this.onSelect();\n        }\n\n        Focus() {\n            if (this.onFocus) this.onFocus();\n        }\n\n        Blur() {\n            if (this.onBlur) this.onBlur();\n        }\n    }\n    \n    // Define the structure of a menu\n    export interface Menu {\n        buttons: MenuButton[]; // List of buttons in the menu\n        selectedIndex: number; // Track index of currently selected button\n        active: boolean; // Track state of menu (visible on screen)\n        cursorSprite?: Sprite; // Optional sprite that visually indicates the selected button\n        onLayoutUpdate?: (menu: Menu) => void; // Optional callback to update the layout when the selection changes\n        usePositionNavigation?: boolean; // Optional toggle for navigation based on button positions\n    }\n\n    // Global event listeners\n    let globalOnSelect: (btn: MenuButton) => void;\n\n    export function onSelect(fn: (btn: MenuButton) => void){\n        globalOnSelect = fn;\n    }\n\n    // Function to create a menu\n    export function createMenu(): Menu {\n        return {\n            buttons: [],\n            selectedIndex: 0, // Start with the first button selected\n            active: true, // Menu is active (visible)\n            usePositionNavigation: false // Default to using index-based navigation\n        }\n    }\n    \n    // Function to create a button\n    export function createButton(sprite: Sprite): IMenuButton {\n        let button: IMenuButton = {\n            sprite: sprite,\n            selectHandler: () => {},\n            highlightHandler: () => {},\n            onUnhighlight: () => {}\n        }\n\n        return button;\n    }\n\n    // Function to add a button to a menuUI\n    export function addButton(menu: Menu, btn: IMenuButton): void {\n        menu.buttons.push(btn);\n    }\n\n    // Function to update the currently selected button in the Menu\n    export function updateSelection(menu: Menu, direction: number | { x: number, y: number}){\n        //Check if we are able to update selection\n        if(!menu.active||menu.buttons.length===0) return;\n\n        const current = menu.buttons[menu.selectedIndex];\n\n        if (current.onUnhighlight) current.onUnhighlight();\n\n        if (menu.usePositionNavigation && typeof direction !== \"number\"){\n            // If we should navigate buttons based on coordinate positions\n            updateSelectionByPosition(menu, direction);\n        } else if (typeof direction === \"number\") {\n            //If we should navigate buttons through the array with index\n            const total = menu.buttons.length;\n            menu.selectedIndex = (menu.selectedIndex + direction + total) % total;\n            //MATH BREAKDOWN\n            /**\n             * selectedIndex is the current index of the selected button in the array of buttons.\n             * we add the direction to the selectedIndex to move up or down the list of buttons.\n             * we also add the total number of buttons to make sure the result is positive \n             * even if the index + direction would go negative. \n             * Ex: if we're at index 0 and move -1, we'd be at button number -1 which is invalid.\n             * we use the modulo operator (%) to wrap the index around the range of our array,\n             * Ex: (3 + 1 + 3) % 3 = (7) % 3 = 1\n             */\n        }\n\n        // Track new button\n        const selectedBtn = menu.buttons[menu.selectedIndex];\n\n        //If using sprite cursor\n        if (menu.cursorSprite){\n            menu.cursorSprite.setPosition(selectedBtn.sprite.x, selectedBtn.sprite.y);\n        }\n\n        if(selectedBtn.highlightHandler) selectedBtn.highlightHandler();\n        if(menu.onLayoutUpdate) menu.onLayoutUpdate(menu);\n    }\n\n    // Function to update the selection based on relative position of the buttons\n    function updateSelectionByPosition(menu: Menu, dir: {x: number, y: number}){\n        const current = menu.buttons[menu.selectedIndex].sprite;\n        let closestIndex = menu.selectedIndex;\n        let closestScore = -Infinity;\n\n        for (let i = 0; i < menu.buttons.length; i++){\n            // Skip selected button\n            if (i === menu.selectedIndex) continue;\n\n            // Calculate distance with pythag\n            const other = menu.buttons[i].sprite;\n            const dx = other.x - current.x;\n            const dy = other.y - current.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist === 0) continue;\n\n            const normDX = dx / dist;\n            const normDY = dy / dist;\n\n            // Dot product to measure how well aligned the two vectors are\n            const dot = normDX * dir.x + normDY * dir.y;\n            // skip buttons that aren't in the intended direction\n            if (dot <= 0.1) continue;\n            // add penalty for distance\n            const score = dot - (dist * 0.01)\n\n            if (score > closestScore) {\n                closestScore = score;\n                closestIndex = i;\n            }\n        }\n        \n        menu.selectedIndex = closestIndex;\n    }\n\n    // Function to confirm the selection of the currently selected buttons\n    export function confirm(menu: Menu) {\n        if (!menu.active) return;\n\n        const selected = menu.buttons[menu.selectedIndex];\n\n        // if we have on selected event, trigger it.\n        if (selected.selectHandler()) selected.selectHandler();\n    }\n\n    // Function to show the Menu\n    export function show(menu: Menu){\n        menu.active = true;\n        for (let btn of menu.buttons) {\n            btn.sprite.setFlag(SpriteFlag.Invisible, false);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n\n    // Function to hide the Menu\n    export function hide(menu: Menu) {\n        menu.active = false;\n        for (let btn of menu.buttons){\n            btn.sprite.setFlag(SpriteFlag.Invisible, true);\n        }\n        if (menu.cursorSprite) menu.cursorSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n\n    // Function to destroy the menu and clean up\n    export function destroy(menu: Menu) {\n        for (let btn of menu.buttons) {\n            sprites.destroy(btn.sprite);\n            }\n        if (menu.cursorSprite) {\n            menu.cursorSprite.destroy();\n            \n        }\n        menu.active = false;\n    }\n}","vectorMath.ts":"// Add your code here\n\nnamespace Math {\n    // Define a 2D vector structure\n    export type Vector2 = { x: number; y: number }\n\n    // Predefined directional vectors\n    export const Vector2 = {\n        up: { x: 0, y: -1 },\n        down: { x: 0, y: 1 },\n        left: { x: -1, y: 0 },\n        right: { x: 1, y: 0 },\n        zero: { x: 0, y: 0 },\n        one: { x: 1, y: 1 },\n\n        // Optional: utility functions\n        add: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x + b.x, y: a.y + b.y }),\n        sub: (a: Vector2, b: Vector2): Vector2 => ({ x: a.x - b.x, y: a.y - b.y }),\n        scale: (v: Vector2, s: number): Vector2 => ({ x: v.x * s, y: v.y * s }),\n        dot: (a: Vector2, b: Vector2): number => a.x * b.x + a.y * b.y,\n        magnitude: (v: Vector2): number => Math.sqrt(v.x * v.x + v.y * v.y),\n        normalize: (v: Vector2): Vector2 => {\n            const mag = Vector2.magnitude(v)\n            return mag === 0 ? Vector2.zero : { x: v.x / mag, y: v.y / mag }\n        }\n    }\n}\n","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQgABAAAAAAiIiIiIiIAICIiIiIiIgIiIiIiIiIiIiIiP+PiI+IiIiIj/iIj4iIiIiPiP+PiIiIiIiIiIiIiIiIj4iIiIiIiIiPiIiIiIiIiP///4+IiIiIj4iIiIiIiIiPiIiIiIiIiIiIiIiIiIiIiPj/j4iIiIj4j4+IiIiIiI+Ij4iIiIiI+I+PiIiIiIiI+P+PiIiIiIiIiIiIiIiI////j4iIiIiP+IiIiIiIiI/4j4iIiIiI+I/4j4iIiIiIiIiIiIiIiI+IiIiIiIiIj4iIiIiIiIj///+PiIiIiI+IiIiIiIiIj4iIiIiIiIiIiIiIiIiAiIiIiIiICACIiIiIiIgA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn\"\n    },\n    \"image2\": {\n        \"data\": \"hwQgABAAAAAAZmZmZmZmAGBmZmZmZmYGZmZmZmZmZmZmZv9vZm9mZmZmb/Zmb2ZmZmZvZv9vZmZmZmZmZmZmZmZmb2ZmZmZmZmZvZmZmZmZmZv///29mZmZmb2ZmZmZmZmZvZmZmZmZmZmZmZmZmZmZmZvb/b2ZmZmb2b29mZmZmZm9mb2ZmZmZm9m9vZmZmZmZm9v9vZmZmZmZmZmZmZmZm////b2ZmZmZv9mZmZmZmZm/2b2ZmZmZm9m/2b2ZmZmZmZmZmZmZmZm9mZmZmZmZmb2ZmZmZmZmb///9vZmZmZm9mZmZmZmZmb2ZmZmZmZmZmZmZmZmZgZmZmZmZmBgBmZmZmZmYA\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"StartBtn0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ArcadeTools\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"text.ts\",\n        \"menus.ts\",\n        \"vectorMath.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1746853527189}